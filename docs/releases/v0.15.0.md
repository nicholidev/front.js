# v0.15.0 Release Notes

This release introduces a new compiler based on esbuild, which is *much* faster than Rollup. In our tests, we've found the new compiler to be anywhere from 100-200x as fast as the current one.

To help with migrating to the new compiler, this release ships with both our current compiler and the new one. So you can upgrade your app to Remix 0.15 and run it on the current compiler, then try out the new compiler and see what breaks. We think you'll enjoy the speed improvements so much that you'll want to switch as soon as possible. The time you spend making the migration will easily be worth the time you *won't* spend waiting on future builds ðŸ˜…

There are also a few minor changes to a few of our packages that are going to help us get onto more platforms in the future. Right now Remix runs only on node. But as more JavaScript runtimes appear on different cloud providers (hello Cloudflare Workers!) we are going to run Remix on all of them.

## Upgrading Summary

To upgrade from Remix 0.14:

- Replace `@remix-run/data` with `@remix-run/node` in your `package.json` dependencies
  - `npm remove @remix-run/data`
  - `npm add @remix-run/node`
- Change all `@remix-run/data` imports to `@remix-run/node`
- Remove deep imports from `@remix-run/react`:
  - In `app/entry.client.js`, change `import Remix from "@remix-run/react/browser"` to `import { RemixBrowser as Remix } from "@remix-run/react"`
  - In `app/entry.server.js`, change `import Remix from "@remix-run/react/server"` to `import { RemixServer as Remix } from "@remix-run/react"`

Please see the "Notes on Package Changes" section below for details on why things are moving around.

As always, remember to use the starters as your guide. We currently have starter repos for:

- [Express](https://github.com/remix-run/starter-express)
- [Architect](https://github.com/remix-run/starter-architect)
- [Vercel](https://github.com/remix-run/starter-vercel)

## Using the New Compiler

This release ships with a new compiler based on esbuild. We have been blown away by how fast esbuild is, and we think you're going to really enjoy the speed improvements too. However, there are some changes you'll need to make to your app in order to use it.

Before you continue, please be sure you **follow the notes in the Upgrading Summary section (above) first**! Once you follow those steps and get your app running on the current compiler, you can come back here.

The first thing you'll need to change is the CLI command you use to invoke the compiler. In this release, `remix build` will still invoke the old compiler and `remix build2` will invoke the new one. Eventually (probably in 0.16) `remix build2` will become `remix build` and we'll remove the old compiler entirely. This is the same for `remix run` and `remix run2`. You can also use `remix watch2` if you just want to run the build in watch mode without firing up the dev server.

The new compiler **does not support** (yet):

- `.client.js` and `.server.js` file extensions
- `url:`, `css:`, and `img:` imports
- `.mdx` route modules

I know that's a lot to drop on you in a single release, but we have better answers for all of them! So please allow me to explain in greater detail.

### Client/server-only Modules

In v0.13 we introduced the `.client.js` and `.server.js` file naming scheme for manually hinting to the compiler which files to include in the build. We used these hints as a way to try and speed up the compiler by giving hints to Rollup about which files it needed to include in the build, but esbuild is so fast that we don't need them anymore.

We still rely on tree-shaking to get rid of server-only code in your client bundles, so that hasn't changed.

If you have browser-only code, instead of using a `.client.js` file extension, just make sure it won't run on the server using a traditional `typeof window` guard:

```js
if (typeof window !== "undefined") {
  // browser-only stuff goes here
}
```

### URL, CSS, and Image Imports

The new compiler includes support for importing many different types of files as URLs including SVG, fonts, CSS, and images. When you `import` a file, it will be copied to the build output and you will get a cacheable (hashed) URL to the asset.

```tsx
import pizzaImageUrl from "../images/pizza.png";

function PizzaImage() {
  return <img src={pizzaImageUrl} />
}
```

We are still working out how we'd like to support CSS and images. esbuild includes several different loaders for different content types, and they are working on native support for CSS and CSS modules, so we are following that work closely to see how it pans out.

As for images, there are many different sources for images. The `img:` import strategy only really works for image files that are stored alongside your source code. But that won't be the case if you have a lot of images or if they are generated by users. So we are rethinking how to best handle these in the new compiler. There are also many different ways to serve images. Services like Akamai and Cloudinary are popular choices for hosting images, and they make it really easy to generate different formats. CDNs like Fastly and Cloudflare also have interesting image optimization capabilities, and it's also very compelling to be able to build them on the fly as needed instead of building it into the build step of your app.

For now, when you import an image or a `.css` file using the new compiler, you'll get a URL to that file. We will also be writing up some detailed guides about the various strategies for handling images and CSS in Remix apps using the new compiler. The guide to using PostCSS in Remix is already a good start.

### MDX Route Modules

The new compiler does not support using `.mdx` files as route modules. Instead, when you `import text from "../pages/something.mdx"` you'll get a string of the text contents of that file.

As we continue working on the new compiler, we are planning on re-introducing first-class support for `.mdx` files as route modules, but in the mean time if you're using MDX, one project you might be interested in is Kent C. Dodds' [mdx-bundler](https://github.com/kentcdodds/mdx-bundler). It's a fast tool (also based on esbuild ðŸ™Œ) that will bundle up your MDX for you and give you the code you need to actually render your component. It'll probably look something like this:

```jsx
import { bundleMDX } from "mdx-bundler";
import { getMDXComponent } from "mdx-bundler/client";
import { useRouteData } from "@remix-run/react";

// You can get the MDX from your own filesystem. But if you have a lot
// of content you're probably going to get this from a database somewhere.
// Maybe you can be fancy and get it directly from GitHub in loader()!
import text from "../pages/something.mdx";

export async function loader() {
  return await bundleMDX(text);
}

export default function MyPage() {
  let { code } = useRouteData();
  let Component = React.useMemo(() => getMDXComponent(code), [code]);
  return <Component />;
}
```

We believe this is a great way to handle MDX; as content instead of source code. Now you don't have to slow down your build compiling a bunch of MDX files!

## Notes on Package Changes

In the last release (0.14) and this one some packages have moved around, and I thought it'd be nice to put a few notes here about how we are thinking about structuring our packages going forward so it's clear why we are making these changes. Hopefully this will clarify how we are thinking about supporting Cloudflare Workers in the near future as well.

We currently ship three separate packages that run on node: `@remix-run/architect`, `@remix-run/express`, and `@remix-run/vercel`. Each package shares a common dependency, `@remix-run/node`, and exports a `createRequestHandler` function that is suited for working with that particular provider's HTTP server API.

In addition, each of these packages has the side effect of creating a few globals when you use it. So e.g. when you `import { createRequestHandler } from "@remix-run/express"` in your `server.js` file (your server entry point), it automatically adds a few node-flavored versions of the Fetch API to node's global scope, including `global.Headers`, `global.Request`, `global.Response`, and `global.fetch`. This is what allows you to use `fetch` in your `loader` without importing anything. It's a nice parallel with the web, where those primitives are already global. And in a server-rendered React app, where the line between node and the browser is already a little blurry, it's nice to not have to import stuff that you expect to already be present when that same code is running in the browser.

In this release, we eliminated the `@remix-run/data` package and elevated `@remix-run/node` to an app-level dependency (in 0.14 it was a transitive dependency called `@remix-run/core`) to more accurately reflect its target runtime. So if you're building a node app with Remix, your app-level dependencies are:

- `@remix-run/node` (the "environment" you're running in)
- Your "provider" (currently `@remix-run/architect`, `@remix-run/express`, or `@remix-run/vercel`)
- `@remix-run/react`

I'm fairly confident we won't have any more package shuffling in any releases in the near future, and I hope this clarifies how we are structuring things on node. We will follow this same pattern to support other JS runtimes in the near future. 
